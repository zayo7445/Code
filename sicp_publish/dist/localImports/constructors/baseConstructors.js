"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createImportNamespaceSpecifier = exports.createImportDefaultSpecifier = exports.createImportSpecifier = exports.createImportDeclaration = exports.createFunctionDeclaration = exports.createReturnStatement = exports.createVariableDeclaration = exports.createVariableDeclarator = exports.createCallExpression = exports.createIdentifier = exports.createLiteral = void 0;
// Note that typecasting is done on some of the constructed AST nodes because
// the ESTree AST node types are not fully aligned with the actual AST that
// is generated by the Acorn parser. However, the extra/missing properties
// are unused in the Source interpreter/transpiler. As such, we can safely
// ignore their existence to make the typing cleaner. The alternative would
// be to define our own AST node types based off the ESTree AST node types
// and use our custom AST node types everywhere.
const createLiteral = (value, raw) => {
    return {
        type: 'Literal',
        value,
        raw: (raw !== null && raw !== void 0 ? raw : typeof value === 'string') ? `"${value}"` : String(value)
    };
};
exports.createLiteral = createLiteral;
const createIdentifier = (name) => {
    return {
        type: 'Identifier',
        name
    };
};
exports.createIdentifier = createIdentifier;
const createCallExpression = (functionName, functionArguments) => {
    return {
        type: 'CallExpression',
        callee: (0, exports.createIdentifier)(functionName),
        arguments: functionArguments
        // The 'optional' property is typed in ESTree, but does not exist
        // on SimpleCallExpression nodes in the AST generated by acorn parser.
    };
};
exports.createCallExpression = createCallExpression;
const createVariableDeclarator = (id, initialValue = null) => {
    return {
        type: 'VariableDeclarator',
        id,
        init: initialValue
    };
};
exports.createVariableDeclarator = createVariableDeclarator;
const createVariableDeclaration = (declarations, kind) => {
    return {
        type: 'VariableDeclaration',
        declarations,
        kind
    };
};
exports.createVariableDeclaration = createVariableDeclaration;
const createReturnStatement = (argument) => {
    return {
        type: 'ReturnStatement',
        argument
    };
};
exports.createReturnStatement = createReturnStatement;
const createFunctionDeclaration = (name, params, body) => {
    return {
        type: 'FunctionDeclaration',
        expression: false,
        generator: false,
        id: {
            type: 'Identifier',
            name
        },
        params,
        body: {
            type: 'BlockStatement',
            body
        }
        // The 'expression' property is not typed in ESTree, but it exists
        // on FunctionDeclaration nodes in the AST generated by acorn parser.
    };
};
exports.createFunctionDeclaration = createFunctionDeclaration;
const createImportDeclaration = (specifiers, source) => {
    return {
        type: 'ImportDeclaration',
        specifiers,
        source
    };
};
exports.createImportDeclaration = createImportDeclaration;
const createImportSpecifier = (local, imported) => {
    return {
        type: 'ImportSpecifier',
        local,
        imported
    };
};
exports.createImportSpecifier = createImportSpecifier;
const createImportDefaultSpecifier = (local) => {
    return {
        type: 'ImportDefaultSpecifier',
        local
    };
};
exports.createImportDefaultSpecifier = createImportDefaultSpecifier;
const createImportNamespaceSpecifier = (local) => {
    return {
        type: 'ImportNamespaceSpecifier',
        local
    };
};
exports.createImportNamespaceSpecifier = createImportNamespaceSpecifier;
//# sourceMappingURL=baseConstructors.js.map